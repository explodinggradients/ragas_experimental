"""A python list like object that contains your evaluation data."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/dataset.ipynb.

# %% auto 0
__all__ = ['PydanticModelType', 'Dataset']

# %% ../nbs/dataset.ipynb 3
import typing as t

from fastcore.utils import patch

from pydantic import BaseModel

from .backends.ragas_api_client import RagasApiClient

# %% ../nbs/dataset.ipynb 4
PydanticModelType = t.TypeVar("PydanticModelType", bound=BaseModel)


class Dataset(t.Generic[PydanticModelType]):
    """A list-like interface for managing NotionModel instances in a Notion database."""

    def __init__(
        self,
        name: str,
        model: t.Type[BaseModel],
        project_id: str,
        dataset_id: str,
        ragas_api_client: RagasApiClient,
    ):
        self.name = name
        self.model = model
        self.project_id = project_id
        self.dataset_id = dataset_id
        self._ragas_api_client = ragas_api_client
        self._entries: t.List[PydanticModelType] = []

    def __getitem__(
        self, key: t.Union[int, slice]
    ) -> t.Union[PydanticModelType, "Dataset[PydanticModelType]"]:
        """Get an entry by index or slice."""
        if isinstance(key, slice):
            new_dataset = type(self)(
                name=self.name,
                model=self.model,
                project_id=self.project_id,
                dataset_id=self.dataset_id,
                ragas_api_client=self._ragas_api_client,
            )
            new_dataset._entries = self._entries[key]
            return new_dataset
        else:
            return self._entries[key]

    def __setitem__(self, index: int, entry: PydanticModelType) -> None:
        """Update an entry at the given index and sync to Notion."""
        if not isinstance(entry, self.model):
            raise TypeError(f"Entry must be an instance of {self.model.__name__}")

        # Get existing entry to get Notion page ID
        existing = self._entries[index]
        if not hasattr(existing, "_page_id"):
            raise ValueError("Existing entry has no page_id")

        # Update in Notion
        assert (
            existing._page_id is not None
        )  # mypy fails to infer that we check for it above
        response = self._ragas_api_client.update_page(
            page_id=existing._page_id, properties=entry.to_notion()["properties"]
        )

        # Update local cache with response data
        self._entries[index] = self.model.from_notion(response)

    def __repr__(self) -> str:
        return (
            f"Dataset(name={self.name}, model={self.model.__name__}, len={len(self)})"
        )

    def __len__(self) -> int:
        return len(self._entries)

    def __iter__(self) -> t.Iterator[PydanticModelType]:
        return iter(self._entries)

# %% ../nbs/dataset.ipynb 14
@patch
def append(self: Dataset, entry: PydanticModelType) -> None:
    """Add a new entry to the dataset and sync to Notion."""
    # Create row inside the table

    # first get the columns for the dataset
    # TODO: this is a hack to get the columns for the dataset
    column_id_map = self.get_column_id_map(dataset_id=self.dataset_id)

    # create the rows
    row_dict = entry.model_dump()
    row_id = create_nano_id()
    row_data = {}
    for key, value in row_dict.items():
        if key in column_id_map:
            row_data[column_id_map[key]] = value

    sync_func = async_to_sync(self._ragas_api_client.create_dataset_row)
    response = sync_func(
        project_id=self.project_id,
        dataset_id=self.dataset_id,
        id=row_id,
        data=row_data,
    )
    # Update entry with Notion data (like ID)
    self._entries.append(entry)

# %% ../nbs/dataset.ipynb 17
@patch
def pop(self: Dataset, index: int = -1) -> PydanticModelType:
    """Remove and return entry at index, sync deletion to Notion."""
    entry = self._entries[index]
    # get the row id
    # TODO: this is a hack to get the row id
    sync_func = async_to_sync(self._ragas_api_client.list_dataset_rows)
    rows = sync_func(project_id=self.project_id, dataset_id=self.dataset_id)
    for row in rows["items"]:
        print(row, entry.id)
    return
    # Archive in Notion (soft delete)
    assert entry._page_id is not None  # mypy fails to infer that we check for it above
    self._ragas_api_client.update_page(page_id=entry._page_id, archived=True)

    # Remove from local cache
    return self._entries.pop(index)

# %% ../nbs/dataset.ipynb 20
@patch
def load(self: Dataset) -> None:
    """Load all entries from the Notion database."""
    # Query the database
    response = self._ragas_api_client.query_database(
        database_id=self.dataset_id, archived=False
    )

    # Clear existing entries
    self._entries.clear()

    # Convert results to model instances
    for page in response.get("results", []):
        entry = self.model.from_notion(page)
        self._entries.append(entry)

# %% ../nbs/dataset.ipynb 25
@patch
def get(self: Dataset, id: int) -> t.Optional[PydanticModelType]:
    """Get an entry by ID."""
    if not self._ragas_api_client:
        return None

    # Query the database for the specific ID
    response = self._ragas_api_client.query_database(
        database_id=self.dataset_id,
        filter={"property": "id", "unique_id": {"equals": id}},
    )

    if not response.get("results"):
        return None

    return self.model.from_notion(response["results"][0])

# %% ../nbs/dataset.ipynb 28
@patch
def save(self: Dataset, item: PydanticModelType) -> None:
    """Save changes to an item to Notion."""
    if not isinstance(item, self.model):
        raise TypeError(f"Item must be an instance of {self.model.__name__}")

    if not hasattr(item, "_page_id"):
        raise ValueError("Item has no page_id")

    # Update in Notion
    assert item._page_id is not None  # mypy fails to infer that we check for it above
    response = self._ragas_api_client.update_page(
        page_id=item._page_id, properties=item.to_notion()["properties"]
    )

    # Update local cache
    for i, existing in enumerate(self._entries):
        if existing._page_id == item._page_id:
            self._entries[i] = self.model.from_notion(response)
            break

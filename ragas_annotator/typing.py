"""Field Metadata for python's `t.Annotate`."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/typing.ipynb.

# %% auto 0
__all__ = ['ColumnType', 'FieldMeta', 'Number', 'Text', 'Select', 'MultiSelect', 'Checkbox', 'Date', 'Custom', 'ModelConverter']

# %% ../nbs/typing.ipynb 2
import typing as t
from enum import Enum
from pydantic import BaseModel, create_model
from datetime import datetime, date
import inspect

# %% ../nbs/typing.ipynb 4
class ColumnType(str, Enum):
    """Column types supported by the Ragas API."""
    NUMBER = "number"
    TEXT = "text"
    SELECT = "select"
    MULTI_SELECT = "multiSelect"
    CHECKBOX = "checkbox"
    DATE = "date"
    CUSTOM = "custom"


# %% ../nbs/typing.ipynb 5
class FieldMeta:
    """Base metadata for field type annotations."""
    def __init__(self, type, required=True, **settings):
        self.type = type
        self.required = required
        self.settings = settings.copy()

# %% ../nbs/typing.ipynb 6
class Number(FieldMeta):
    """Number field metadata."""
    def __init__(self, min_value: t.Optional[float] = None, max_value: t.Optional[float] = None, required: bool = True):
        settings = {}
        if min_value is not None or max_value is not None:
            settings["range"] = {}
            if min_value is not None:
                settings["range"]["min"] = min_value
            if max_value is not None:
                settings["range"]["max"] = max_value
        super().__init__(ColumnType.NUMBER, required, **settings)


# %% ../nbs/typing.ipynb 7
class Text(FieldMeta):
    """Text field metadata."""
    def __init__(self, max_length: int = 1000, required: bool = True):
        settings = {}
        if max_length is not None:
            settings["max_length"] = max_length
        super().__init__(ColumnType.TEXT, required, **settings)

# %% ../nbs/typing.ipynb 8
class Select(FieldMeta):
    """Select field metadata."""
    def __init__(self, options: t.Optional[t.List[str]] = None, required: bool = True):
        settings = {}
        if options:
            settings["options"] = [{"name": option} for option in options]
        super().__init__(ColumnType.SELECT, required, **settings)

# %% ../nbs/typing.ipynb 9
class MultiSelect(FieldMeta):
    """MultiSelect field metadata."""
    def __init__(self, options: t.Optional[t.List[str]] = None, required: bool = True):
        settings = {}
        if options:
            settings["options"] = [{"name": option} for option in options]
        super().__init__(ColumnType.MULTI_SELECT, required, **settings)


# %% ../nbs/typing.ipynb 10
class Checkbox(FieldMeta):
    """Checkbox field metadata."""
    def __init__(self, required: bool = True):
        super().__init__(ColumnType.CHECKBOX, required)


# %% ../nbs/typing.ipynb 11
class Date(FieldMeta):
    """Date field metadata."""
    def __init__(self, include_time: bool = False, required: bool = True):
        settings = {}
        if include_time:
            settings["include_time"] = include_time
        super().__init__(ColumnType.DATE, required, **settings)


# %% ../nbs/typing.ipynb 12
class Custom(FieldMeta):
    """Custom field metadata."""
    def __init__(self, custom_type: str = "", required: bool = True):
        settings = {}
        if custom_type:
            settings["type"] = custom_type
        super().__init__(ColumnType.CUSTOM, required, **settings)

# %% ../nbs/typing.ipynb 14
class ModelConverter:
    """Convert Pydantic models to Ragas API columns and rows."""
    
    @staticmethod
    def infer_field_type(annotation, field_info=None):
        """Infer field type from Python type annotation."""
        # Check for Annotated with our custom metadata
        origin = t.get_origin(annotation)
        args = t.get_args(annotation)
        
        # If this is an Annotated field with our metadata
        if origin is t.Annotated and len(args) > 1:
            for arg in args[1:]:
                if isinstance(arg, FieldMeta):
                    return arg
            
            # If no field metadata found, infer from the base type
            return ModelConverter.infer_field_type(args[0], field_info)
        
        # Handle Optional, List, etc.
        if origin is t.Union:
            if type(None) in args:
                # This is Optional[T]
                non_none_args = [arg for arg in args if arg is not type(None)]
                if len(non_none_args) == 1:
                    # Get the field type of the non-None arg
                    field_meta = ModelConverter.infer_field_type(non_none_args[0], field_info)
                    field_meta.required = False
                    return field_meta
        
        # Handle List and array types
        # NOTE: here we are converting lists to strings, except for literal types
        if origin is list or origin is t.List:
            if len(args) > 0:
                # Check if it's a list of literals
                if t.get_origin(args[0]) is t.Literal:
                    literal_options = t.get_args(args[0])
                    return MultiSelect(options=list(literal_options))
                # Otherwise just a regular list
                return Text()  # Default to Text for lists
        
        # Handle Literal
        if origin is t.Literal:
            return Select(options=list(args))
        
        # Basic type handling
        if annotation is str:
            return Text()
        elif annotation is int or annotation is float:
            return Number()
        elif annotation is bool:
            return Checkbox()
        elif annotation is datetime or annotation is date:
            return Date(include_time=annotation is datetime)
        
        # Default to Text for complex or unknown types
        return Text()
    
    @classmethod
    def model_to_columns(cls, model_class):
        """Convert a Pydantic model class to Ragas API column definitions."""
        columns = []
        for field_name, field_info in model_class.model_fields.items():
            # Get the field's type annotation
            annotation = field_info.annotation
            
            # Try to get field metadata
            field_meta = cls.infer_field_type(annotation, field_info)
            
            # Create column definition
            column = {
                "id": field_name,
                "name": field_name,
                "type": field_meta.type.value,
                "settings": field_meta.settings.copy()
            }
            
            columns.append(column)
        
        return columns
    
    @classmethod
    def instance_to_row(cls, instance, model_class=None):
        """Convert a Pydantic model instance to a Ragas API row."""
        if model_class is None:
            model_class = instance.__class__
        
        row_cells = []
        model_data = instance.model_dump()
        
        for field_name, field_info in model_class.model_fields.items():
            if field_name in model_data:
                value = model_data[field_name]
                # Process value based on field type
                annotation = field_info.annotation
                field_meta = cls.infer_field_type(annotation, field_info)
                
                # Special handling for various types
                if field_meta.type == ColumnType.MULTI_SELECT and isinstance(value, list):
                    # Convert list to string format accepted by API
                    processed_value = value
                elif field_meta.type == ColumnType.DATE and isinstance(value, (datetime, date)):
                    # Format date as string
                    processed_value = value.isoformat()
                else:
                    processed_value = value
                
                row_cells.append({
                    "column_id": field_name,
                    "data": processed_value
                })
        
        return {
            "data": row_cells
        }
    
    @classmethod
    def instances_to_rows(cls, instances, model_class=None):
        """Convert multiple Pydantic model instances to Ragas API rows."""
        if not instances:
            return []
        
        if model_class is None and instances:
            model_class = instances[0].__class__
        
        return [cls.instance_to_row(instance, model_class) for instance in instances]
